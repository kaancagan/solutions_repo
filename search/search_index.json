{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Motivation Projectile motion, though seemingly basic, offers a deep and insightful perspective into core physics concepts. The primary objective here is to explore how the range of a projectile varies as a function of the angle of projection . While the problem setup appears straightforward, it conceals a rich mathematical structure involving both linear and quadratic relationships. This topic is fascinating due to several influencing variables, such as: Initial velocity ( \\(v_0\\) ) Gravitational acceleration ( \\(g\\) ) Launch height ( \\(h\\) ) Each of these parameters contributes to a wide array of physical trajectories \u2014 from a soccer ball's curved path to a space rocket's arc. 2. Theoretical Foundation The equations governing projectile motion are derived using Newton\u2019s Second Law: 2.1. Equations of Motion In an idealized scenario (neglecting air resistance), the forces acting on a projectile are: Gravitational force in the vertical direction No horizontal forces From Newton\u2019s laws: Horizontal acceleration: $$ a_x = 0 $$ Vertical acceleration: $$ a_y = -g $$ Integrating over time \\(t\\) , we get the velocity components: \\[ v_x = v_0 \\cos(\\theta) \\] \\[ v_y = v_0 \\sin(\\theta) - gt \\] Integrating again gives the position equations: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] These define the horizontal (constant velocity) and vertical (accelerated) motions. 2.2. Time of Flight To find the total time the projectile remains in the air, set \\(y(t) = 0\\) (assuming launch and landing occur at the same height): \\[ t = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 2.3. Range Equation The range \\(R\\) is the total horizontal distance traveled before the projectile lands: Using horizontal motion: \\[ R = v_0 \\cos(\\theta) \\cdot t \\] Substitute time of flight: \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Apply the identity: \\[ \\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta) \\] Final equation for range: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 2.4. Maximum Range The range is maximized when \\(\\sin(2\\theta)\\) is at its peak value (which is 1): \\[ \\theta = 45^\\circ \\] Therefore, the maximum range occurs at a launch angle of \\(45^\\circ\\) when launch and landing heights are the same. 3. Range Analysis 3.1. Dependence on Angle The function \\(R(\\theta)\\) is symmetric around \\(45^\\circ\\) Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) yield the same range 3.2. Effect of Initial Velocity The range increases quadratically with initial speed: \\[ R \\propto v_0^2 \\] 3.3. Effect of Gravitational Acceleration Higher gravity (e.g., Jupiter) \u2192 shorter range Lower gravity (e.g., Moon) \u2192 longer range Summary Projectile range is influenced by several physical parameters, but follows a clear mathematical structure. By understanding the role of each parameter, especially the angle of projection, one can predict and optimize the trajectory of various real-world projectiles. Visualization with Air Resistance","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motivation","text":"Projectile motion, though seemingly basic, offers a deep and insightful perspective into core physics concepts. The primary objective here is to explore how the range of a projectile varies as a function of the angle of projection . While the problem setup appears straightforward, it conceals a rich mathematical structure involving both linear and quadratic relationships. This topic is fascinating due to several influencing variables, such as: Initial velocity ( \\(v_0\\) ) Gravitational acceleration ( \\(g\\) ) Launch height ( \\(h\\) ) Each of these parameters contributes to a wide array of physical trajectories \u2014 from a soccer ball's curved path to a space rocket's arc.","title":"1. Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"The equations governing projectile motion are derived using Newton\u2019s Second Law:","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-equations-of-motion","text":"In an idealized scenario (neglecting air resistance), the forces acting on a projectile are: Gravitational force in the vertical direction No horizontal forces From Newton\u2019s laws: Horizontal acceleration: $$ a_x = 0 $$ Vertical acceleration: $$ a_y = -g $$ Integrating over time \\(t\\) , we get the velocity components: \\[ v_x = v_0 \\cos(\\theta) \\] \\[ v_y = v_0 \\sin(\\theta) - gt \\] Integrating again gives the position equations: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] These define the horizontal (constant velocity) and vertical (accelerated) motions.","title":"2.1. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-time-of-flight","text":"To find the total time the projectile remains in the air, set \\(y(t) = 0\\) (assuming launch and landing occur at the same height): \\[ t = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"2.2. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#23-range-equation","text":"The range \\(R\\) is the total horizontal distance traveled before the projectile lands: Using horizontal motion: \\[ R = v_0 \\cos(\\theta) \\cdot t \\] Substitute time of flight: \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Apply the identity: \\[ \\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta) \\] Final equation for range: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"2.3. Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#24-maximum-range","text":"The range is maximized when \\(\\sin(2\\theta)\\) is at its peak value (which is 1): \\[ \\theta = 45^\\circ \\] Therefore, the maximum range occurs at a launch angle of \\(45^\\circ\\) when launch and landing heights are the same.","title":"2.4. Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-range-analysis","text":"","title":"3. Range Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-dependence-on-angle","text":"The function \\(R(\\theta)\\) is symmetric around \\(45^\\circ\\) Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) yield the same range","title":"3.1. Dependence on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-effect-of-initial-velocity","text":"The range increases quadratically with initial speed: \\[ R \\propto v_0^2 \\]","title":"3.2. Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-effect-of-gravitational-acceleration","text":"Higher gravity (e.g., Jupiter) \u2192 shorter range Lower gravity (e.g., Moon) \u2192 longer range","title":"3.3. Effect of Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Projectile range is influenced by several physical parameters, but follows a clear mathematical structure. By understanding the role of each parameter, especially the angle of projection, one can predict and optimize the trajectory of various real-world projectiles. Visualization with Air Resistance","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system exhibiting intricate behavior due to the interplay of damping, restoring forces, and external periodic forces. By introducing damping and external forcing, the system transitions from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena provide insights into real-world systems, such as driven oscillators, climate models, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. Systematic variations in these parameters reveal synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors highlight fundamental physics principles and provide engineering insights into energy harvesting, vibration isolation, and mechanical resonance. Task 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is described by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = F_0 \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(F_0\\) is the amplitude of the external force, - \\(\\omega\\) is the driving frequency. Approximate Solutions for Small-Angle Oscillations For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F_0 \\cos(\\omega t) \\] Solving this using standard techniques yields solutions representing driven damped harmonic oscillations. Resonance Conditions Resonance occurs when the driving frequency \\(\\omega\\) matches the system\u2019s natural frequency \\(\\omega_0\\) , leading to energy amplification. The impact of damping on resonance behavior and its practical implications in engineering are discussed. 2. Analysis of Dynamics Influence of the damping coefficient, driving amplitude, and frequency on motion. Transition from periodic to chaotic motion. Physical interpretations of regular and chaotic motion, explored via phase portraits and bifurcation diagrams. 3. Practical Applications Energy Harvesting : Mechanical resonance in energy collection devices. Suspension Bridges : Understanding resonance-induced structural failures. Oscillating Circuits : Analogies to driven RLC circuits. 4. Implementation Computational Model Using Python, we numerically solve the forced damped pendulum equation using the Runge-Kutta method and visualize the results. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, gamma, omega0, F0, omega): theta, omega_t = y dydt = [ omega_t, -gamma * omega_t - omega0**2 * np.sin(theta) + F0 * np.cos(omega * t) ] return dydt # Parameters gamma = 0.2 # Damping coefficient omega0 = 1.0 # Natural frequency F0 = 0.5 # Driving force amplitude omega = 0.8 # Driving frequency time_span = (0, 50) # Simulation time initial_conditions = [0.1, 0] # Initial theta and angular velocity time_eval = np.linspace(*time_span, 1000) # Solve the differential equation solution = solve_ivp( forced_damped_pendulum, time_span, initial_conditions, t_eval=time_eval, args=(gamma, omega0, F0, omega) ) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=\"Theta (rad)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() Visualization Time evolution of \\(\\theta(t)\\) for different parameters. Phase diagrams illustrating different motion regimes. Poincar\u00e9 sections and bifurcation diagrams to explore chaotic behavior. Deliverables Markdown document with explanations and Python implementations. Graphical representations of motion under varying conditions. Discussion on model limitations and potential extensions, such as nonlinear damping and non-periodic driving forces. Phase portraits and bifurcation diagrams for understanding transitions to complex dynamics. Hints and Resources Use small-angle approximations where valid. Apply numerical techniques (Runge-Kutta) for beyond-small-angle exploration. Relate the pendulum dynamics to driven RLC circuits and biomechanics. Utilize Python for simulations and visualizations. This study bridges theoretical analysis and computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena in physics and engineering.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system exhibiting intricate behavior due to the interplay of damping, restoring forces, and external periodic forces. By introducing damping and external forcing, the system transitions from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena provide insights into real-world systems, such as driven oscillators, climate models, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. Systematic variations in these parameters reveal synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors highlight fundamental physics principles and provide engineering insights into energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is described by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = F_0 \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(F_0\\) is the amplitude of the external force, - \\(\\omega\\) is the driving frequency.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solutions-for-small-angle-oscillations","text":"For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F_0 \\cos(\\omega t) \\] Solving this using standard techniques yields solutions representing driven damped harmonic oscillations.","title":"Approximate Solutions for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the system\u2019s natural frequency \\(\\omega_0\\) , leading to energy amplification. The impact of damping on resonance behavior and its practical implications in engineering are discussed.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Influence of the damping coefficient, driving amplitude, and frequency on motion. Transition from periodic to chaotic motion. Physical interpretations of regular and chaotic motion, explored via phase portraits and bifurcation diagrams.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Mechanical resonance in energy collection devices. Suspension Bridges : Understanding resonance-induced structural failures. Oscillating Circuits : Analogies to driven RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-model","text":"Using Python, we numerically solve the forced damped pendulum equation using the Runge-Kutta method and visualize the results. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, gamma, omega0, F0, omega): theta, omega_t = y dydt = [ omega_t, -gamma * omega_t - omega0**2 * np.sin(theta) + F0 * np.cos(omega * t) ] return dydt # Parameters gamma = 0.2 # Damping coefficient omega0 = 1.0 # Natural frequency F0 = 0.5 # Driving force amplitude omega = 0.8 # Driving frequency time_span = (0, 50) # Simulation time initial_conditions = [0.1, 0] # Initial theta and angular velocity time_eval = np.linspace(*time_span, 1000) # Solve the differential equation solution = solve_ivp( forced_damped_pendulum, time_span, initial_conditions, t_eval=time_eval, args=(gamma, omega0, F0, omega) ) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=\"Theta (rad)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Computational Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualization","text":"Time evolution of \\(\\theta(t)\\) for different parameters. Phase diagrams illustrating different motion regimes. Poincar\u00e9 sections and bifurcation diagrams to explore chaotic behavior.","title":"Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"Markdown document with explanations and Python implementations. Graphical representations of motion under varying conditions. Discussion on model limitations and potential extensions, such as nonlinear damping and non-periodic driving forces. Phase portraits and bifurcation diagrams for understanding transitions to complex dynamics.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#hints-and-resources","text":"Use small-angle approximations where valid. Apply numerical techniques (Runge-Kutta) for beyond-small-angle exploration. Relate the pendulum dynamics to driven RLC circuits and biomechanics. Utilize Python for simulations and visualizations. This study bridges theoretical analysis and computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena in physics and engineering.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows us to determine planetary motions and understand gravitational interactions on both local and cosmic scales. By analyzing this relationship, we can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Derivation of Kepler's Third Law for Circular Orbits Consider a body of mass \\(m\\) orbiting around a much more massive body of mass \\(M\\) in a circular orbit of radius \\(r\\) . From Newton's Law of Universal Gravitation: \\[ F_g = \\frac{G M m}{r^2} \\] From circular motion (centripetal force): \\[ F_c = \\frac{m v^2}{r} \\] Equating gravitational force to centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify: \\[ \\frac{G M}{r} = v^2 \\] Orbital period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Therefore: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This is Kepler's Third Law : The square of the orbital period is proportional to the cube of the orbital radius. Python Simulation of Circular Orbits import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) Orbital radii (in meters) radii = np.linspace(1e7, 5e8, 100) # from 10,000 km to 500,000 km Compute orbital periods using Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) Plotting plt.figure(figsize=(8,6)) plt.plot(radii / 1e6, periods / 3600, label=r' \\(T \\propto r^{3/2}\\) ') # hours plt.xlabel('Orbital Radius (x \\(10^6\\) m)') plt.ylabel('Orbital Period (hours)') plt.title('Orbital Period vs Radius (Kepler\\'s Third Law)') plt.grid(True) plt.legend() plt.show()","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows us to determine planetary motions and understand gravitational interactions on both local and cosmic scales. By analyzing this relationship, we can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"Consider a body of mass \\(m\\) orbiting around a much more massive body of mass \\(M\\) in a circular orbit of radius \\(r\\) . From Newton's Law of Universal Gravitation: \\[ F_g = \\frac{G M m}{r^2} \\] From circular motion (centripetal force): \\[ F_c = \\frac{m v^2}{r} \\] Equating gravitational force to centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify: \\[ \\frac{G M}{r} = v^2 \\] Orbital period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Therefore: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This is Kepler's Third Law : The square of the orbital period is proportional to the cube of the orbital radius.","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-of-circular-orbits","text":"import numpy as np import matplotlib.pyplot as plt","title":"Python Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-radii-in-meters","text":"radii = np.linspace(1e7, 5e8, 100) # from 10,000 km to 500,000 km","title":"Orbital radii (in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#compute-orbital-periods-using-keplers-third-law","text":"periods = 2 * np.pi * np.sqrt(radii**3 / (G * M))","title":"Compute orbital periods using Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plotting","text":"plt.figure(figsize=(8,6)) plt.plot(radii / 1e6, periods / 3600, label=r' \\(T \\propto r^{3/2}\\) ') # hours plt.xlabel('Orbital Radius (x \\(10^6\\) m)') plt.ylabel('Orbital Period (hours)') plt.title('Orbital Period vs Radius (Kepler\\'s Third Law)') plt.grid(True) plt.legend() plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is fundamental in understanding how to overcome a celestial body's gravitational pull. Expanding on this, the first , second , and third cosmic velocities describe the minimum speeds needed to: 1. Maintain a circular orbit (1st cosmic velocity), 2. Escape the body's gravity (2nd cosmic velocity), 3. Escape the solar system (3rd cosmic velocity). These principles guide space missions from satellite launches to interplanetary and interstellar exploration. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ) The minimum velocity required for an object to enter a stable circular orbit around a celestial body. Derived from: \\(\\frac{G M}{r} = v_1^2\\) \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Second Cosmic Velocity ( \\(v_2\\) ) The escape velocity , or the speed needed to completely break free from a celestial body's gravity. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} \\] Third Cosmic Velocity ( \\(v_3\\) ) The speed needed to escape not just the planet, but also its parent star's gravity (e.g., Earth + Sun). Approximate (simplified): \\[ v_3 \\approx \\sqrt{v_{sun}^2 + v_2^2} \\] Where \\(v_{sun}\\) is the orbital speed of the planet around the Sun. Python Implementation and Visualization import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) Celestial bodies: (mass in kg, radius in m) bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"v_sun\": 29.78e3}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.3895e6, \"v_sun\": 24.07e3}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.9911e7, \"v_sun\": 13.07e3} } Compute velocities results = {} for name, data in bodies.items(): M = data[\"M\"] R = data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 v3 = np.sqrt(v2 2 + data[\"v_sun\"] 2) results[name] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} Display results for name, v in results.items(): print(f\"\\n{name}:\") print(f\" First Cosmic Velocity (Orbit): {v['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (Escape): {v['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (Interstellar): {v['v3'] / 1000:.2f} km/s\") Plotting labels = list(results.keys()) v1_vals = [results[body]['v1'] / 1000 for body in labels] v2_vals = [results[body]['v2'] / 1000 for body in labels] v3_vals = [results[body]['v3'] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(10,6)) plt.bar(x - width, v1_vals, width, label='v1 (Orbit)') plt.bar(x, v2_vals, width, label='v2 (Escape)') plt.bar(x + width, v3_vals, width, label='v3 (Solar Escape)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(x, labels) plt.legend() plt.grid(True, axis='y') plt.tight_layout() plt.show()","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is fundamental in understanding how to overcome a celestial body's gravitational pull. Expanding on this, the first , second , and third cosmic velocities describe the minimum speeds needed to: 1. Maintain a circular orbit (1st cosmic velocity), 2. Escape the body's gravity (2nd cosmic velocity), 3. Escape the solar system (3rd cosmic velocity). These principles guide space missions from satellite launches to interplanetary and interstellar exploration.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"The minimum velocity required for an object to enter a stable circular orbit around a celestial body. Derived from: \\(\\frac{G M}{r} = v_1^2\\) \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\]","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"The escape velocity , or the speed needed to completely break free from a celestial body's gravity. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} \\]","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"The speed needed to escape not just the planet, but also its parent star's gravity (e.g., Earth + Sun). Approximate (simplified): \\[ v_3 \\approx \\sqrt{v_{sun}^2 + v_2^2} \\] Where \\(v_{sun}\\) is the orbital speed of the planet around the Sun.","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt","title":"Python Implementation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-bodies-mass-in-kg-radius-in-m","text":"bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"v_sun\": 29.78e3}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.3895e6, \"v_sun\": 24.07e3}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.9911e7, \"v_sun\": 13.07e3} }","title":"Celestial bodies: (mass in kg, radius in m)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#compute-velocities","text":"results = {} for name, data in bodies.items(): M = data[\"M\"] R = data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 v3 = np.sqrt(v2 2 + data[\"v_sun\"] 2) results[name] = {\"v1\": v1, \"v2\": v2, \"v3\": v3}","title":"Compute velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#display-results","text":"for name, v in results.items(): print(f\"\\n{name}:\") print(f\" First Cosmic Velocity (Orbit): {v['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (Escape): {v['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (Interstellar): {v['v3'] / 1000:.2f} km/s\")","title":"Display results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plotting","text":"labels = list(results.keys()) v1_vals = [results[body]['v1'] / 1000 for body in labels] v2_vals = [results[body]['v2'] / 1000 for body in labels] v3_vals = [results[body]['v3'] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(10,6)) plt.bar(x - width, v1_vals, width, label='v1 (Orbit)') plt.bar(x, v2_vals, width, label='v2 (Escape)') plt.bar(x + width, v3_vals, width, label='v3 (Solar Escape)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(x, labels) plt.legend() plt.grid(True, axis='y') plt.tight_layout() plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its trajectory is governed by gravity and its initial velocity. The result could be: A circular or elliptical orbit (if speed is below escape velocity), A parabolic trajectory (if speed equals escape velocity), A hyperbolic trajectory (if speed exceeds escape velocity), Or a reentry if the speed is insufficient to sustain orbit. These outcomes are critical for satellite deployment, deorbiting modules, and interplanetary missions. Theoretical Background The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] This force causes acceleration toward Earth: \\[ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth's mass, - \\(r\\) is the distance to Earth's center. The trajectory depends on the initial velocity vector \\(\\vec{v}_0\\) . Depending on \\(|\\vec{v}_0|\\) , the object may fall back, orbit, or escape. Python Simulation of Payload Trajectories We use numerical integration (Euler or Runge-Kutta) to simulate the path. import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth) R_earth = 6.371e6 # m (Earth radius) Time setup dt = 1 # seconds t_max = 10000 # total simulation time in seconds steps = int(t_max / dt) Initial conditions altitude = 400e3 # 400 km above Earth r0 = np.array([R_earth + altitude, 0]) # initial position speeds = [5000, 7670, 11000, 11200] # vary speed to test different paths (m/s) labels = ['Reentry', 'Stable Orbit', 'Escape', 'Hyperbolic'] def simulate_trajectory(v0_mag): r = r0.copy() v = np.array([0, v0_mag]) traj = [r.copy()] for _ in range(steps): r_mag = np.linalg.norm(r) a = -G * M / r_mag**3 * r v += a * dt r += v * dt if r_mag < R_earth: break # crashed traj.append(r.copy()) return np.array(traj) Plot all trajectories plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) plt.plot(earth_x, earth_y, 'b', label='Earth') for v0, label in zip(speeds, labels): traj = simulate_trajectory(v0) plt.plot(traj[:,0], traj[:,1], label=f'{label} ({v0/1000:.1f} km/s)') plt.axis('equal') plt.grid(True) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Payload Trajectories from 400 km Altitude') plt.legend() plt.show()","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its trajectory is governed by gravity and its initial velocity. The result could be: A circular or elliptical orbit (if speed is below escape velocity), A parabolic trajectory (if speed equals escape velocity), A hyperbolic trajectory (if speed exceeds escape velocity), Or a reentry if the speed is insufficient to sustain orbit. These outcomes are critical for satellite deployment, deorbiting modules, and interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] This force causes acceleration toward Earth: \\[ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth's mass, - \\(r\\) is the distance to Earth's center. The trajectory depends on the initial velocity vector \\(\\vec{v}_0\\) . Depending on \\(|\\vec{v}_0|\\) , the object may fall back, orbit, or escape.","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-of-payload-trajectories","text":"We use numerical integration (Euler or Runge-Kutta) to simulate the path. import numpy as np import matplotlib.pyplot as plt","title":"Python Simulation of Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth) R_earth = 6.371e6 # m (Earth radius)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-setup","text":"dt = 1 # seconds t_max = 10000 # total simulation time in seconds steps = int(t_max / dt)","title":"Time setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"altitude = 400e3 # 400 km above Earth r0 = np.array([R_earth + altitude, 0]) # initial position speeds = [5000, 7670, 11000, 11200] # vary speed to test different paths (m/s) labels = ['Reentry', 'Stable Orbit', 'Escape', 'Hyperbolic'] def simulate_trajectory(v0_mag): r = r0.copy() v = np.array([0, v0_mag]) traj = [r.copy()] for _ in range(steps): r_mag = np.linalg.norm(r) a = -G * M / r_mag**3 * r v += a * dt r += v * dt if r_mag < R_earth: break # crashed traj.append(r.copy()) return np.array(traj)","title":"Initial conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-all-trajectories","text":"plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) plt.plot(earth_x, earth_y, 'b', label='Earth') for v0, label in zip(speeds, labels): traj = simulate_trajectory(v0) plt.plot(traj[:,0], traj[:,1], label=f'{label} ({v0/1000:.1f} km/s)') plt.axis('equal') plt.grid(True) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Payload Trajectories from 400 km Altitude') plt.legend() plt.show()","title":"Plot all trajectories"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a Water Surface Motivation When waves from multiple sources meet on a water surface, they interfere \u2014 adding or canceling each other depending on their phase. This project simulates interference patterns from coherent point sources placed at the vertices of a regular polygon . Problem Setup We simulate wave interference from 4 coherent sources placed at the vertices of a square . Each source emits circular waves of the same frequency, amplitude, and phase. The resulting displacement at each point on the water surface is given by: \\[ u(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\sin(k r_i - \\omega t + \\phi) \\] Where: - \\(A\\) : amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number - \\(\\omega = 2\\pi f\\) : angular frequency - \\(r_i\\) : distance from source \\(i\\) to point \\((x, y)\\) - \\(N\\) : number of sources Python Simulation import numpy as np import matplotlib.pyplot as plt Parameters A = 1.0 # Amplitude \u03bb = 1.0 # Wavelength (meters) f = 1.0 # Frequency (Hz) \u03c9 = 2 * np.pi * f # Angular frequency k = 2 * np.pi / \u03bb # Wave number \u03c6 = 0 # Initial phase N = 4 # Number of sources (square) Grid setup grid_size = 200 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) Polygon vertices (square centered at origin, side length 4) side = 4 L = side / np.sqrt(2) sources = [ (-L, -L), (-L, L), (L, -L), (L, L) ] Time snapshot t = 0 # You can change this or animate over time Superpose waves from all sources U = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0) 2 + (Y - y0) 2) U += A * np.sin(k * r - \u03c9 * t + \u03c6) Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, U, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter( zip( sources), color='red', label='Sources') plt.title('Wave Interference Pattern (Square Configuration)') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.axis('equal') plt.grid(False) plt.show() Observations The bright regions correspond to constructive interference (waves reinforcing). The dark regions are areas of destructive interference (waves cancelling). The symmetric pattern arises from the square geometry of the source placement. Next Steps Try other polygons: triangle (3), pentagon (5), hexagon (6) Animate the surface: simulate time evolution with t varying Try random phases or incoherent sources Conclusion This simulation shows how simple wave equations can create beautiful and complex interference patterns . Understanding these patterns helps explain physical phenomena from sound and light to quantum waves. \ud83d\udca7 \"Where waves meet, patterns emerge.\"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"When waves from multiple sources meet on a water surface, they interfere \u2014 adding or canceling each other depending on their phase. This project simulates interference patterns from coherent point sources placed at the vertices of a regular polygon .","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-setup","text":"We simulate wave interference from 4 coherent sources placed at the vertices of a square . Each source emits circular waves of the same frequency, amplitude, and phase. The resulting displacement at each point on the water surface is given by: \\[ u(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\sin(k r_i - \\omega t + \\phi) \\] Where: - \\(A\\) : amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) : wave number - \\(\\omega = 2\\pi f\\) : angular frequency - \\(r_i\\) : distance from source \\(i\\) to point \\((x, y)\\) - \\(N\\) : number of sources","title":"Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt","title":"Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"A = 1.0 # Amplitude \u03bb = 1.0 # Wavelength (meters) f = 1.0 # Frequency (Hz) \u03c9 = 2 * np.pi * f # Angular frequency k = 2 * np.pi / \u03bb # Wave number \u03c6 = 0 # Initial phase N = 4 # Number of sources (square)","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#grid-setup","text":"grid_size = 200 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y)","title":"Grid setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#polygon-vertices-square-centered-at-origin-side-length-4","text":"side = 4 L = side / np.sqrt(2) sources = [ (-L, -L), (-L, L), (L, -L), (L, L) ]","title":"Polygon vertices (square centered at origin, side length 4)"},{"location":"1%20Physics/3%20Waves/Problem_1/#time-snapshot","text":"t = 0 # You can change this or animate over time","title":"Time snapshot"},{"location":"1%20Physics/3%20Waves/Problem_1/#superpose-waves-from-all-sources","text":"U = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0) 2 + (Y - y0) 2) U += A * np.sin(k * r - \u03c9 * t + \u03c6)","title":"Superpose waves from all sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#plotting","text":"plt.figure(figsize=(8, 6)) plt.contourf(X, Y, U, levels=100, cmap='viridis') plt.colorbar(label='Wave Displacement') plt.scatter( zip( sources), color='red', label='Sources') plt.title('Wave Interference Pattern (Square Configuration)') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.axis('equal') plt.grid(False) plt.show()","title":"Plotting"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"The bright regions correspond to constructive interference (waves reinforcing). The dark regions are areas of destructive interference (waves cancelling). The symmetric pattern arises from the square geometry of the source placement.","title":"Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#next-steps","text":"Try other polygons: triangle (3), pentagon (5), hexagon (6) Animate the surface: simulate time evolution with t varying Try random phases or incoherent sources","title":"Next Steps"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation shows how simple wave equations can create beautiful and complex interference patterns . Understanding these patterns helps explain physical phenomena from sound and light to quantum waves. \ud83d\udca7 \"Where waves meet, patterns emerge.\"","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}