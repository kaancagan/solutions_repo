{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Deriving the Governing Equations The motion of a projectile can be described by applying Newton's second law. For a projectile launched from an initial position with velocity \\(v_0\\) at an angle \\(\\theta\\) with respect to the horizontal, we have: In the horizontal direction (x-axis): \\( \\(\\frac{d^2x}{dt^2} = 0\\) \\) In the vertical direction (y-axis): \\( \\(\\frac{d^2y}{dt^2} = -g\\) \\) Where \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2 on Earth). Integrating these equations with respect to time with initial conditions: - \\(x(0) = 0\\) - \\(y(0) = h\\) (initial height) - \\(v_x(0) = v_0\\cos(\\theta)\\) - \\(v_y(0) = v_0\\sin(\\theta)\\) We obtain: \\[x(t) = (v_0\\cos\\theta)t$$ $$y(t) = h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2\\] These parametric equations describe the position of the projectile at any time \\(t\\) . Family of Solutions The family of solutions is defined by varying the parameters: - Initial velocity ( \\(v_0\\) ) - Launch angle ( \\(\\theta\\) ) - Initial height ( \\(h\\) ) - Gravitational acceleration ( \\(g\\) ) Each combination of these parameters produces a unique trajectory. 2. Analysis of the Range Range Equation The range \\(R\\) is the horizontal distance traveled when the projectile returns to its initial height. To find this, we need to determine when \\(y(t) = h\\) : \\[h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = h\\] Simplifying: \\( \\((v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = 0\\) \\) This equation has two solutions: \\(t = 0\\) and \\(t = \\frac{2v_0\\sin\\theta}{g}\\) The second solution gives us the time of flight. The range is then: \\[R = (v_0\\cos\\theta) \\cdot \\frac{2v_0\\sin\\theta}{g} = \\frac{v_0^2\\sin(2\\theta)}{g}\\] This demonstrates that the range is proportional to: - The square of the initial velocity - The sine of twice the angle of projection - Inversely proportional to the gravitational acceleration Optimal Angle for Maximum Range To find the angle that maximizes the range, we differentiate with respect to \\(\\theta\\) and set it equal to zero: \\[\\frac{dR}{d\\theta} = \\frac{v_0^2\\cos(2\\theta)}{g} = 0\\] This gives us \\(\\cos(2\\theta) = 0\\) , thus \\(2\\theta = \\frac{\\pi}{2}\\) or \\(\\theta = \\frac{\\pi}{4} = 45\u00b0\\) Therefore, in the absence of air resistance and with a level landing surface, the maximum range is achieved at a 45\u00b0 angle. Effect of Initial Height If the projectile is launched from a height \\(h\\) above the landing surface, the range equation becomes more complex: \\[R = v_0\\cos\\theta \\cdot t_{landing}\\] Where \\(t_{landing}\\) is the time when the projectile reaches the ground level ( \\(y = 0\\) ): \\[h + (v_0\\sin\\theta)t_{landing} - \\frac{1}{2}gt_{landing}^2 = 0\\] Solving this quadratic equation: \\[t_{landing} = \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\] This means that the range now depends on the initial height as well: \\[R = v_0\\cos\\theta \\cdot \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\] 3. Practical Applications Real-world Considerations In practice, projectile motion is influenced by: - Air resistance (drag) - Wind - Varying gravitational field - Rotating reference frames (Coriolis effect) - Non-uniform terrain Incorporating Air Resistance A simple model for air resistance is to include a drag force proportional to velocity: \\[F_d = -bv\\] This leads to a modified set of differential equations: \\[\\frac{d^2x}{dt^2} = -\\frac{b}{m}v_x$$ $$\\frac{d^2y}{dt^2} = -g - \\frac{b}{m}v_y\\] Where \\(b\\) is the drag coefficient and \\(m\\) is the mass of the projectile. These equations typically require numerical methods to solve. 4. pyhton Implementation","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-the-governing-equations","text":"The motion of a projectile can be described by applying Newton's second law. For a projectile launched from an initial position with velocity \\(v_0\\) at an angle \\(\\theta\\) with respect to the horizontal, we have: In the horizontal direction (x-axis): \\( \\(\\frac{d^2x}{dt^2} = 0\\) \\) In the vertical direction (y-axis): \\( \\(\\frac{d^2y}{dt^2} = -g\\) \\) Where \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2 on Earth). Integrating these equations with respect to time with initial conditions: - \\(x(0) = 0\\) - \\(y(0) = h\\) (initial height) - \\(v_x(0) = v_0\\cos(\\theta)\\) - \\(v_y(0) = v_0\\sin(\\theta)\\) We obtain: \\[x(t) = (v_0\\cos\\theta)t$$ $$y(t) = h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2\\] These parametric equations describe the position of the projectile at any time \\(t\\) .","title":"Deriving the Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The family of solutions is defined by varying the parameters: - Initial velocity ( \\(v_0\\) ) - Launch angle ( \\(\\theta\\) ) - Initial height ( \\(h\\) ) - Gravitational acceleration ( \\(g\\) ) Each combination of these parameters produces a unique trajectory.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"The range \\(R\\) is the horizontal distance traveled when the projectile returns to its initial height. To find this, we need to determine when \\(y(t) = h\\) : \\[h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = h\\] Simplifying: \\( \\((v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = 0\\) \\) This equation has two solutions: \\(t = 0\\) and \\(t = \\frac{2v_0\\sin\\theta}{g}\\) The second solution gives us the time of flight. The range is then: \\[R = (v_0\\cos\\theta) \\cdot \\frac{2v_0\\sin\\theta}{g} = \\frac{v_0^2\\sin(2\\theta)}{g}\\] This demonstrates that the range is proportional to: - The square of the initial velocity - The sine of twice the angle of projection - Inversely proportional to the gravitational acceleration","title":"Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#optimal-angle-for-maximum-range","text":"To find the angle that maximizes the range, we differentiate with respect to \\(\\theta\\) and set it equal to zero: \\[\\frac{dR}{d\\theta} = \\frac{v_0^2\\cos(2\\theta)}{g} = 0\\] This gives us \\(\\cos(2\\theta) = 0\\) , thus \\(2\\theta = \\frac{\\pi}{2}\\) or \\(\\theta = \\frac{\\pi}{4} = 45\u00b0\\) Therefore, in the absence of air resistance and with a level landing surface, the maximum range is achieved at a 45\u00b0 angle.","title":"Optimal Angle for Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-height","text":"If the projectile is launched from a height \\(h\\) above the landing surface, the range equation becomes more complex: \\[R = v_0\\cos\\theta \\cdot t_{landing}\\] Where \\(t_{landing}\\) is the time when the projectile reaches the ground level ( \\(y = 0\\) ): \\[h + (v_0\\sin\\theta)t_{landing} - \\frac{1}{2}gt_{landing}^2 = 0\\] Solving this quadratic equation: \\[t_{landing} = \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\] This means that the range now depends on the initial height as well: \\[R = v_0\\cos\\theta \\cdot \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\]","title":"Effect of Initial Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-considerations","text":"In practice, projectile motion is influenced by: - Air resistance (drag) - Wind - Varying gravitational field - Rotating reference frames (Coriolis effect) - Non-uniform terrain","title":"Real-world Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#incorporating-air-resistance","text":"A simple model for air resistance is to include a drag force proportional to velocity: \\[F_d = -bv\\] This leads to a modified set of differential equations: \\[\\frac{d^2x}{dt^2} = -\\frac{b}{m}v_x$$ $$\\frac{d^2y}{dt^2} = -g - \\frac{b}{m}v_y\\] Where \\(b\\) is the drag coefficient and \\(m\\) is the mass of the projectile. These equations typically require numerical methods to solve.","title":"Incorporating Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-pyhton-implementation","text":"","title":"4. pyhton Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system exhibiting intricate behavior due to the interplay of damping, restoring forces, and external periodic forces. By introducing damping and external forcing, the system transitions from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena provide insights into real-world systems, such as driven oscillators, climate models, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. Systematic variations in these parameters reveal synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors highlight fundamental physics principles and provide engineering insights into energy harvesting, vibration isolation, and mechanical resonance. Task 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is described by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = F_0 \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(F_0\\) is the amplitude of the external force, - \\(\\omega\\) is the driving frequency. Approximate Solutions for Small-Angle Oscillations For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F_0 \\cos(\\omega t) \\] Solving this using standard techniques yields solutions representing driven damped harmonic oscillations. Resonance Conditions Resonance occurs when the driving frequency \\(\\omega\\) matches the system\u2019s natural frequency \\(\\omega_0\\) , leading to energy amplification. The impact of damping on resonance behavior and its practical implications in engineering are discussed. 2. Analysis of Dynamics Influence of the damping coefficient, driving amplitude, and frequency on motion. Transition from periodic to chaotic motion. Physical interpretations of regular and chaotic motion, explored via phase portraits and bifurcation diagrams. 3. Practical Applications Energy Harvesting : Mechanical resonance in energy collection devices. Suspension Bridges : Understanding resonance-induced structural failures. Oscillating Circuits : Analogies to driven RLC circuits. 4. Implementation Computational Model Using Python, we numerically solve the forced damped pendulum equation using the Runge-Kutta method and visualize the results. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, gamma, omega0, F0, omega): theta, omega_t = y dydt = [ omega_t, -gamma * omega_t - omega0**2 * np.sin(theta) + F0 * np.cos(omega * t) ] return dydt # Parameters gamma = 0.2 # Damping coefficient omega0 = 1.0 # Natural frequency F0 = 0.5 # Driving force amplitude omega = 0.8 # Driving frequency time_span = (0, 50) # Simulation time initial_conditions = [0.1, 0] # Initial theta and angular velocity time_eval = np.linspace(*time_span, 1000) # Solve the differential equation solution = solve_ivp( forced_damped_pendulum, time_span, initial_conditions, t_eval=time_eval, args=(gamma, omega0, F0, omega) ) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=\"Theta (rad)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() Visualization Time evolution of \\(\\theta(t)\\) for different parameters. Phase diagrams illustrating different motion regimes. Poincar\u00e9 sections and bifurcation diagrams to explore chaotic behavior. Deliverables Markdown document with explanations and Python implementations. Graphical representations of motion under varying conditions. Discussion on model limitations and potential extensions, such as nonlinear damping and non-periodic driving forces. Phase portraits and bifurcation diagrams for understanding transitions to complex dynamics. Hints and Resources Use small-angle approximations where valid. Apply numerical techniques (Runge-Kutta) for beyond-small-angle exploration. Relate the pendulum dynamics to driven RLC circuits and biomechanics. Utilize Python for simulations and visualizations. This study bridges theoretical analysis and computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena in physics and engineering.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system exhibiting intricate behavior due to the interplay of damping, restoring forces, and external periodic forces. By introducing damping and external forcing, the system transitions from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena provide insights into real-world systems, such as driven oscillators, climate models, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. Systematic variations in these parameters reveal synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors highlight fundamental physics principles and provide engineering insights into energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is described by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = F_0 \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(F_0\\) is the amplitude of the external force, - \\(\\omega\\) is the driving frequency.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solutions-for-small-angle-oscillations","text":"For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F_0 \\cos(\\omega t) \\] Solving this using standard techniques yields solutions representing driven damped harmonic oscillations.","title":"Approximate Solutions for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the system\u2019s natural frequency \\(\\omega_0\\) , leading to energy amplification. The impact of damping on resonance behavior and its practical implications in engineering are discussed.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Influence of the damping coefficient, driving amplitude, and frequency on motion. Transition from periodic to chaotic motion. Physical interpretations of regular and chaotic motion, explored via phase portraits and bifurcation diagrams.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Mechanical resonance in energy collection devices. Suspension Bridges : Understanding resonance-induced structural failures. Oscillating Circuits : Analogies to driven RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-model","text":"Using Python, we numerically solve the forced damped pendulum equation using the Runge-Kutta method and visualize the results. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, gamma, omega0, F0, omega): theta, omega_t = y dydt = [ omega_t, -gamma * omega_t - omega0**2 * np.sin(theta) + F0 * np.cos(omega * t) ] return dydt # Parameters gamma = 0.2 # Damping coefficient omega0 = 1.0 # Natural frequency F0 = 0.5 # Driving force amplitude omega = 0.8 # Driving frequency time_span = (0, 50) # Simulation time initial_conditions = [0.1, 0] # Initial theta and angular velocity time_eval = np.linspace(*time_span, 1000) # Solve the differential equation solution = solve_ivp( forced_damped_pendulum, time_span, initial_conditions, t_eval=time_eval, args=(gamma, omega0, F0, omega) ) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=\"Theta (rad)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Computational Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualization","text":"Time evolution of \\(\\theta(t)\\) for different parameters. Phase diagrams illustrating different motion regimes. Poincar\u00e9 sections and bifurcation diagrams to explore chaotic behavior.","title":"Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"Markdown document with explanations and Python implementations. Graphical representations of motion under varying conditions. Discussion on model limitations and potential extensions, such as nonlinear damping and non-periodic driving forces. Phase portraits and bifurcation diagrams for understanding transitions to complex dynamics.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#hints-and-resources","text":"Use small-angle approximations where valid. Apply numerical techniques (Runge-Kutta) for beyond-small-angle exploration. Relate the pendulum dynamics to driven RLC circuits and biomechanics. Utilize Python for simulations and visualizations. This study bridges theoretical analysis and computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena in physics and engineering.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows us to determine planetary motions and understand gravitational interactions on both local and cosmic scales. By analyzing this relationship, we can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Derivation of Kepler's Third Law for Circular Orbits Consider a body of mass \\(m\\) orbiting around a much more massive body of mass \\(M\\) in a circular orbit of radius \\(r\\) . From Newton's Law of Universal Gravitation: \\[ F_g = \\frac{G M m}{r^2} \\] From circular motion (centripetal force): \\[ F_c = \\frac{m v^2}{r} \\] Equating gravitational force to centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify: \\[ \\frac{G M}{r} = v^2 \\] Orbital period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Therefore: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This is Kepler's Third Law : The square of the orbital period is proportional to the cube of the orbital radius. Python Simulation of Circular Orbits import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) Orbital radii (in meters) radii = np.linspace(1e7, 5e8, 100) # from 10,000 km to 500,000 km Compute orbital periods using Kepler's Third Law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) Plotting plt.figure(figsize=(8,6)) plt.plot(radii / 1e6, periods / 3600, label=r' \\(T \\propto r^{3/2}\\) ') # hours plt.xlabel('Orbital Radius (x \\(10^6\\) m)') plt.ylabel('Orbital Period (hours)') plt.title('Orbital Period vs Radius (Kepler\\'s Third Law)') plt.grid(True) plt.legend() plt.show()","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows us to determine planetary motions and understand gravitational interactions on both local and cosmic scales. By analyzing this relationship, we can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"Consider a body of mass \\(m\\) orbiting around a much more massive body of mass \\(M\\) in a circular orbit of radius \\(r\\) . From Newton's Law of Universal Gravitation: \\[ F_g = \\frac{G M m}{r^2} \\] From circular motion (centripetal force): \\[ F_c = \\frac{m v^2}{r} \\] Equating gravitational force to centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify: \\[ \\frac{G M}{r} = v^2 \\] Orbital period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\(v\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Therefore: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This is Kepler's Third Law : The square of the orbital period is proportional to the cube of the orbital radius.","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-of-circular-orbits","text":"import numpy as np import matplotlib.pyplot as plt","title":"Python Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-radii-in-meters","text":"radii = np.linspace(1e7, 5e8, 100) # from 10,000 km to 500,000 km","title":"Orbital radii (in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#compute-orbital-periods-using-keplers-third-law","text":"periods = 2 * np.pi * np.sqrt(radii**3 / (G * M))","title":"Compute orbital periods using Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plotting","text":"plt.figure(figsize=(8,6)) plt.plot(radii / 1e6, periods / 3600, label=r' \\(T \\propto r^{3/2}\\) ') # hours plt.xlabel('Orbital Radius (x \\(10^6\\) m)') plt.ylabel('Orbital Period (hours)') plt.title('Orbital Period vs Radius (Kepler\\'s Third Law)') plt.grid(True) plt.legend() plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is fundamental in understanding how to overcome a celestial body's gravitational pull. Expanding on this, the first , second , and third cosmic velocities describe the minimum speeds needed to: 1. Maintain a circular orbit (1st cosmic velocity), 2. Escape the body's gravity (2nd cosmic velocity), 3. Escape the solar system (3rd cosmic velocity). These principles guide space missions from satellite launches to interplanetary and interstellar exploration. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ) The minimum velocity required for an object to enter a stable circular orbit around a celestial body. Derived from: \\(\\frac{G M}{r} = v_1^2\\) \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Second Cosmic Velocity ( \\(v_2\\) ) The escape velocity , or the speed needed to completely break free from a celestial body's gravity. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} \\] Third Cosmic Velocity ( \\(v_3\\) ) The speed needed to escape not just the planet, but also its parent star's gravity (e.g., Earth + Sun). Approximate (simplified): \\[ v_3 \\approx \\sqrt{v_{sun}^2 + v_2^2} \\] Where \\(v_{sun}\\) is the orbital speed of the planet around the Sun. Python Implementation and Visualization import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) Celestial bodies: (mass in kg, radius in m) bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"v_sun\": 29.78e3}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.3895e6, \"v_sun\": 24.07e3}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.9911e7, \"v_sun\": 13.07e3} } Compute velocities results = {} for name, data in bodies.items(): M = data[\"M\"] R = data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 v3 = np.sqrt(v2 2 + data[\"v_sun\"] 2) results[name] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} Display results for name, v in results.items(): print(f\"\\n{name}:\") print(f\" First Cosmic Velocity (Orbit): {v['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (Escape): {v['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (Interstellar): {v['v3'] / 1000:.2f} km/s\") Plotting labels = list(results.keys()) v1_vals = [results[body]['v1'] / 1000 for body in labels] v2_vals = [results[body]['v2'] / 1000 for body in labels] v3_vals = [results[body]['v3'] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(10,6)) plt.bar(x - width, v1_vals, width, label='v1 (Orbit)') plt.bar(x, v2_vals, width, label='v2 (Escape)') plt.bar(x + width, v3_vals, width, label='v3 (Solar Escape)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(x, labels) plt.legend() plt.grid(True, axis='y') plt.tight_layout() plt.show()","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is fundamental in understanding how to overcome a celestial body's gravitational pull. Expanding on this, the first , second , and third cosmic velocities describe the minimum speeds needed to: 1. Maintain a circular orbit (1st cosmic velocity), 2. Escape the body's gravity (2nd cosmic velocity), 3. Escape the solar system (3rd cosmic velocity). These principles guide space missions from satellite launches to interplanetary and interstellar exploration.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"The minimum velocity required for an object to enter a stable circular orbit around a celestial body. Derived from: \\(\\frac{G M}{r} = v_1^2\\) \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\]","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"The escape velocity , or the speed needed to completely break free from a celestial body's gravity. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2 G M}{r}} \\]","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"The speed needed to escape not just the planet, but also its parent star's gravity (e.g., Earth + Sun). Approximate (simplified): \\[ v_3 \\approx \\sqrt{v_{sun}^2 + v_2^2} \\] Where \\(v_{sun}\\) is the orbital speed of the planet around the Sun.","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt","title":"Python Implementation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-bodies-mass-in-kg-radius-in-m","text":"bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"v_sun\": 29.78e3}, \"Mars\": {\"M\": 6.417e23, \"R\": 3.3895e6, \"v_sun\": 24.07e3}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.9911e7, \"v_sun\": 13.07e3} }","title":"Celestial bodies: (mass in kg, radius in m)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#compute-velocities","text":"results = {} for name, data in bodies.items(): M = data[\"M\"] R = data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2) * v1 v3 = np.sqrt(v2 2 + data[\"v_sun\"] 2) results[name] = {\"v1\": v1, \"v2\": v2, \"v3\": v3}","title":"Compute velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#display-results","text":"for name, v in results.items(): print(f\"\\n{name}:\") print(f\" First Cosmic Velocity (Orbit): {v['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (Escape): {v['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (Interstellar): {v['v3'] / 1000:.2f} km/s\")","title":"Display results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plotting","text":"labels = list(results.keys()) v1_vals = [results[body]['v1'] / 1000 for body in labels] v2_vals = [results[body]['v2'] / 1000 for body in labels] v3_vals = [results[body]['v3'] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(10,6)) plt.bar(x - width, v1_vals, width, label='v1 (Orbit)') plt.bar(x, v2_vals, width, label='v2 (Escape)') plt.bar(x + width, v3_vals, width, label='v3 (Solar Escape)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth, Mars, and Jupiter') plt.xticks(x, labels) plt.legend() plt.grid(True, axis='y') plt.tight_layout() plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its trajectory is governed by gravity and its initial velocity. The result could be: A circular or elliptical orbit (if speed is below escape velocity), A parabolic trajectory (if speed equals escape velocity), A hyperbolic trajectory (if speed exceeds escape velocity), Or a reentry if the speed is insufficient to sustain orbit. These outcomes are critical for satellite deployment, deorbiting modules, and interplanetary missions. Theoretical Background The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] This force causes acceleration toward Earth: \\[ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth's mass, - \\(r\\) is the distance to Earth's center. The trajectory depends on the initial velocity vector \\(\\vec{v}_0\\) . Depending on \\(|\\vec{v}_0|\\) , the object may fall back, orbit, or escape. Python Simulation of Payload Trajectories We use numerical integration (Euler or Runge-Kutta) to simulate the path. import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth) R_earth = 6.371e6 # m (Earth radius) Time setup dt = 1 # seconds t_max = 10000 # total simulation time in seconds steps = int(t_max / dt) Initial conditions altitude = 400e3 # 400 km above Earth r0 = np.array([R_earth + altitude, 0]) # initial position speeds = [5000, 7670, 11000, 11200] # vary speed to test different paths (m/s) labels = ['Reentry', 'Stable Orbit', 'Escape', 'Hyperbolic'] def simulate_trajectory(v0_mag): r = r0.copy() v = np.array([0, v0_mag]) traj = [r.copy()] for _ in range(steps): r_mag = np.linalg.norm(r) a = -G * M / r_mag**3 * r v += a * dt r += v * dt if r_mag < R_earth: break # crashed traj.append(r.copy()) return np.array(traj) Plot all trajectories plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) plt.plot(earth_x, earth_y, 'b', label='Earth') for v0, label in zip(speeds, labels): traj = simulate_trajectory(v0) plt.plot(traj[:,0], traj[:,1], label=f'{label} ({v0/1000:.1f} km/s)') plt.axis('equal') plt.grid(True) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Payload Trajectories from 400 km Altitude') plt.legend() plt.show()","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its trajectory is governed by gravity and its initial velocity. The result could be: A circular or elliptical orbit (if speed is below escape velocity), A parabolic trajectory (if speed equals escape velocity), A hyperbolic trajectory (if speed exceeds escape velocity), Or a reentry if the speed is insufficient to sustain orbit. These outcomes are critical for satellite deployment, deorbiting modules, and interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"The motion of a payload near Earth is governed by Newton's Law of Gravitation : \\[ F = \\frac{G M m}{r^2} \\] This force causes acceleration toward Earth: \\[ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth's mass, - \\(r\\) is the distance to Earth's center. The trajectory depends on the initial velocity vector \\(\\vec{v}_0\\) . Depending on \\(|\\vec{v}_0|\\) , the object may fall back, orbit, or escape.","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation-of-payload-trajectories","text":"We use numerical integration (Euler or Runge-Kutta) to simulate the path. import numpy as np import matplotlib.pyplot as plt","title":"Python Simulation of Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg (Earth) R_earth = 6.371e6 # m (Earth radius)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-setup","text":"dt = 1 # seconds t_max = 10000 # total simulation time in seconds steps = int(t_max / dt)","title":"Time setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"altitude = 400e3 # 400 km above Earth r0 = np.array([R_earth + altitude, 0]) # initial position speeds = [5000, 7670, 11000, 11200] # vary speed to test different paths (m/s) labels = ['Reentry', 'Stable Orbit', 'Escape', 'Hyperbolic'] def simulate_trajectory(v0_mag): r = r0.copy() v = np.array([0, v0_mag]) traj = [r.copy()] for _ in range(steps): r_mag = np.linalg.norm(r) a = -G * M / r_mag**3 * r v += a * dt r += v * dt if r_mag < R_earth: break # crashed traj.append(r.copy()) return np.array(traj)","title":"Initial conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-all-trajectories","text":"plt.figure(figsize=(8,8)) theta = np.linspace(0, 2*np.pi, 100) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) plt.plot(earth_x, earth_y, 'b', label='Earth') for v0, label in zip(speeds, labels): traj = simulate_trajectory(v0) plt.plot(traj[:,0], traj[:,1], label=f'{label} ({v0/1000:.1f} km/s)') plt.axis('equal') plt.grid(True) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Payload Trajectories from 400 km Altitude') plt.legend() plt.show()","title":"Plot all trajectories"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}